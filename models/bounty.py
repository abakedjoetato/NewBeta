"""
Bounty model for the Tower of Temptation PvP Statistics Discord Bot.

This module provides a Bounty class to interact with bounty data in MongoDB.
"""
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import uuid

class Bounty:
    """
    Bounty model for creating and managing player bounties
    """
    
    # Bounty status constants
    STATUS_ACTIVE = "active"
    STATUS_CLAIMED = "claimed"
    STATUS_EXPIRED = "expired"
    STATUS_CANCELLED = "cancelled"
    
    # Bounty type constants
    TYPE_PLAYER = "player"        # Placed by a player
    TYPE_AUTO = "auto"            # Auto-generated by the system
    TYPE_SYSTEM = "system"        # Created by an admin
    
    # Auto-bounty reason constants
    AUTO_REASON_KILLSTREAK = "killstreak"
    AUTO_REASON_TARGET_FIXATION = "target_fixation"
    
    @staticmethod
    async def create(db, guild_id: str, server_id: str, 
                    target_player_id: str, target_player_name: str,
                    reward: int, placed_by: str, placed_by_name: str,
                    expiry_minutes: int = 60,
                    description: Optional[str] = None,
                    bounty_type: str = "player",
                    auto_reason: Optional[str] = None) -> Dict[str, Any]:
        """
        Create a new bounty record
        
        Args:
            db: Database connection
            guild_id: Discord guild ID
            server_id: Game server ID
            target_player_id: Target player ID
            target_player_name: Target player name
            reward: Bounty reward amount
            placed_by: Discord ID of the user who placed the bounty
            placed_by_name: Name of the user who placed the bounty
            expiry_minutes: Minutes until bounty expires
            description: Bounty description
            bounty_type: Type of bounty (player, auto, system)
            auto_reason: Reason for auto-bounty (killstreak, target_fixation)
            
        Returns:
            Dictionary containing the created bounty data
        """
        bounty_id = str(uuid.uuid4())
        created_at = datetime.utcnow()
        expires_at = created_at + timedelta(minutes=expiry_minutes)
        
        bounty_data = {
            "bounty_id": bounty_id,
            "guild_id": guild_id,
            "server_id": server_id,
            "target_player_id": target_player_id,
            "target_player_name": target_player_name,
            "reward": reward,
            "placed_by": placed_by,
            "placed_by_name": placed_by_name,
            "created_at": created_at,
            "expires_at": expires_at,
            "description": description,
            "status": Bounty.STATUS_ACTIVE,
            "claimed_by": None,
            "claimed_by_name": None,
            "claimed_at": None,
            "bounty_type": bounty_type,
            "auto_reason": auto_reason
        }
        
        result = await db.db.bounties.insert_one(bounty_data)
        bounty_data["_id"] = result.inserted_id
        return bounty_data
    
    @staticmethod
    async def get_by_id(db, bounty_id: str) -> Optional[Dict[str, Any]]:
        """
        Get bounty by ID
        
        Args:
            db: Database connection
            bounty_id: Bounty ID
            
        Returns:
            Bounty data dictionary or None if not found
        """
        return await db.db.bounties.find_one({"bounty_id": bounty_id})
    
    @staticmethod
    async def get_active_bounties(db, guild_id: str, server_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get all active bounties for a guild, optionally filtered by server
        
        Args:
            db: Database connection
            guild_id: Discord guild ID
            server_id: Game server ID (optional)
            
        Returns:
            List of bounty data dictionaries
        """
        query = {
            "guild_id": guild_id,
            "status": Bounty.STATUS_ACTIVE,
            "expires_at": {"$gt": datetime.utcnow()}  # Not expired
        }
        
        if server_id:
            query["server_id"] = server_id
            
        cursor = db.db.bounties.find(query).sort("created_at", -1)
        return await cursor.to_list(length=100)
    
    @staticmethod
    async def get_player_active_bounties(db, guild_id: str, 
                                       target_player_id: str) -> List[Dict[str, Any]]:
        """
        Get all active bounties for a specific player
        
        Args:
            db: Database connection
            guild_id: Discord guild ID
            target_player_id: Target player ID
            
        Returns:
            List of bounty data dictionaries
        """
        query = {
            "guild_id": guild_id,
            "target_player_id": target_player_id,
            "status": Bounty.STATUS_ACTIVE,
            "expires_at": {"$gt": datetime.utcnow()}  # Not expired
        }
            
        cursor = db.db.bounties.find(query).sort("created_at", -1)
        return await cursor.to_list(length=100)
    
    @staticmethod
    async def get_player_placed_bounties(db, guild_id: str, 
                                       placed_by: str) -> List[Dict[str, Any]]:
        """
        Get all bounties placed by a specific player
        
        Args:
            db: Database connection
            guild_id: Discord guild ID
            placed_by: Discord ID of the user who placed bounties
            
        Returns:
            List of bounty data dictionaries
        """
        query = {
            "guild_id": guild_id,
            "placed_by": placed_by
        }
            
        cursor = db.db.bounties.find(query).sort("created_at", -1)
        return await cursor.to_list(length=100)
    
    @staticmethod
    async def update_status(db, bounty_id: str, status: str) -> bool:
        """
        Update a bounty's status
        
        Args:
            db: Database connection
            bounty_id: Bounty ID
            status: New status
            
        Returns:
            True if successful, False otherwise
        """
        result = await db.db.bounties.update_one(
            {"bounty_id": bounty_id},
            {"$set": {"status": status}}
        )
        return result.modified_count > 0
    
    @staticmethod
    async def claim_bounty(db, bounty_id: str, claimed_by: str, 
                         claimed_by_name: str) -> bool:
        """
        Mark a bounty as claimed
        
        Args:
            db: Database connection
            bounty_id: Bounty ID
            claimed_by: Discord ID of the user who claimed the bounty
            claimed_by_name: Name of the user who claimed the bounty
            
        Returns:
            True if successful, False otherwise
        """
        result = await db.db.bounties.update_one(
            {"bounty_id": bounty_id},
            {
                "$set": {
                    "status": Bounty.STATUS_CLAIMED,
                    "claimed_by": claimed_by,
                    "claimed_by_name": claimed_by_name,
                    "claimed_at": datetime.utcnow()
                }
            }
        )
        return result.modified_count > 0
    
    @staticmethod
    async def expire_old_bounties(db) -> int:
        """
        Find and expire all bounties that have passed their expiration date
        
        Args:
            db: Database connection
            
        Returns:
            Number of bounties expired
        """
        result = await db.db.bounties.update_many(
            {
                "status": Bounty.STATUS_ACTIVE,
                "expires_at": {"$lte": datetime.utcnow()}
            },
            {"$set": {"status": Bounty.STATUS_EXPIRED}}
        )
        return result.modified_count
    
    @staticmethod
    async def is_killstreak_candidate(db, server_id: str, player_id: str, 
                                    min_kills: int = 5, time_window_minutes: int = 30) -> bool:
        """
        Check if a player is on a kill streak and should have an auto-bounty
        
        Args:
            db: Database connection
            server_id: Game server ID
            player_id: Player ID
            min_kills: Minimum kills to consider a streak
            time_window_minutes: Time window to check for kills
            
        Returns:
            True if player is a candidate, False otherwise
        """
        from models.player import Player
        
        # Check if player exists
        player = await Player.get_by_player_id(db, server_id, player_id)
        if not player:
            return False
        
        # Check for active bounties already on this player
        active_bounties = await Bounty.get_player_active_bounties(db, server_id, player_id)
        if active_bounties:
            return False
        
        # Get kill events in the last time window
        time_cutoff = datetime.utcnow() - timedelta(minutes=time_window_minutes)
        
        # TODO: Implement the actual kill streak detection logic
        # For now, just check if player has enough kills total
        return player.get("kills", 0) >= min_kills
    
    @staticmethod
    async def is_target_fixation_candidate(db, server_id: str, player_id: str, 
                                         min_ratio: float = 0.6, 
                                         min_kills: int = 3) -> bool:
        """
        Check if a player has target fixation (keeps killing the same player)
        
        Args:
            db: Database connection
            server_id: Game server ID
            player_id: Player ID
            min_ratio: Minimum ratio of kills on primary target to total kills
            min_kills: Minimum kills on the same target
            
        Returns:
            True if player is a candidate, False otherwise
        """
        from models.player import Player
        
        # Check if player exists
        player = await Player.get_by_player_id(db, server_id, player_id)
        if not player:
            return False
        
        # Check for active bounties already on this player
        active_bounties = await Bounty.get_player_active_bounties(db, server_id, player_id)
        if active_bounties:
            return False
        
        # Check if player has a prey with min kills
        prey_kills = player.get("prey_kills", 0)
        total_kills = player.get("kills", 0)
        
        if prey_kills < min_kills:
            return False
            
        if total_kills == 0:
            return False
            
        # Calculate ratio of kills on primary target
        ratio = prey_kills / total_kills
        
        return ratio >= min_ratio